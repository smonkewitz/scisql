<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">





<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>sciSQL 0.3.11 Documentation</title>
	<link href="docs.css" type="text/css" rel="stylesheet" />
	<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="prettify/prettify.js"></script>
	<script type="text/javascript" src="jquery-1.6.1.min.js"></script>
</head>

<body>
<div id="header">sciSQL 0.3.11: Science Tools for MySQL</div>
<div id="index">Index</div>
<div id="title"></div>

<div id="nav">
<ul>
	<li>
		
	<h3><a href="#overview">Overview</a></h3>

		

	</li>
	<li>
		
	<h3><a href="#install">Build, Installation, and Deployment</a></h3>

		

	</li>
	<li>
		
	<h3><a href="#s2">Spherical Geometry</a></h3>

		
		<h4>UDFs</h4>
		<ul class="section_nav">
			<li><a href="#s2-scisql_angSep" title="Returns the angular separation in degrees between two positions on the unit sphere.">scisql_angSep</a></li>
			<li><a href="#s2-scisql_s2CPolyHtmRanges" title="Returns a binary-string representation of HTM ID ranges overlapping a spherical convex polygon.">scisql_s2CPolyHtmRanges</a></li>
			<li><a href="#s2-scisql_s2CPolyToBin" title="Returns a binary-string representation of a spherical convex polygon.">scisql_s2CPolyToBin</a></li>
			<li><a href="#s2-scisql_s2CircleHtmRanges" title="Returns a binary-string representation of HTM ID ranges overlapping a circle on the unit sphere.">scisql_s2CircleHtmRanges</a></li>
			<li><a href="#s2-scisql_s2HtmId" title="Returns the HTM ID of a point at the given subdivision level.">scisql_s2HtmId</a></li>
			<li><a href="#s2-scisql_s2HtmLevel" title="Returns the subdivision level of the given HTM ID.">scisql_s2HtmLevel</a></li>
			<li><a href="#s2-scisql_s2PtInBox" title="Returns 1 if the point (lon, lat) lies inside the given longitude/latitude angle box, and 0 otherwise.">scisql_s2PtInBox</a></li>
			<li><a href="#s2-scisql_s2PtInCPoly" title="Returns 1 if the point (lon, lat) lies inside the given spherical convex polygon and 0 otherwise.">scisql_s2PtInCPoly</a></li>
			<li><a href="#s2-scisql_s2PtInCircle" title="Returns 1 if the point (lon, lat) lies inside the given spherical circle and 0 otherwise.">scisql_s2PtInCircle</a></li>
			<li><a href="#s2-scisql_s2PtInEllipse" title="Returns 1 if the point (lon, lat) lies inside the given spherical ellipse and 0 otherwise.">scisql_s2PtInEllipse</a></li>
		</ul>
		<h4>Stored Procedures</h4>
		<ul class="section_nav">
			<li><a href="#s2-scisql_s2CPolyRegion" title="Creates a temporary table `scisql.">scisql_s2CPolyRegion</a></li>
			<li><a href="#s2-scisql_s2CircleRegion" title="Creates a temporary table `scisql.">scisql_s2CircleRegion</a></li>
		</ul>

	</li>
	<li>
		
	<h3><a href="#photometry">Photometry</a></h3>

		
		<ul class="section_nav">
			<li><a href="#photometry-scisql_abMagToDn" title="Converts an AB magnitude to a raw flux in DN.">scisql_abMagToDn</a></li>
			<li><a href="#photometry-scisql_abMagToDnSigma" title="Converts an AB magnitude error to a raw flux error in DN.">scisql_abMagToDnSigma</a></li>
			<li><a href="#photometry-scisql_abMagToFlux" title="Converts an AB magnitude to a calibrated flux.">scisql_abMagToFlux</a></li>
			<li><a href="#photometry-scisql_abMagToFluxSigma" title="Converts an AB magnitude error to a calibrated flux error.">scisql_abMagToFluxSigma</a></li>
			<li><a href="#photometry-scisql_abMagToNanojansky" title="Converts an AB magnitude to a calibrated flux.">scisql_abMagToNanojansky</a></li>
			<li><a href="#photometry-scisql_abMagToNanojanskySigma" title="Converts an AB magnitude error to a calibrated flux error.">scisql_abMagToNanojanskySigma</a></li>
			<li><a href="#photometry-scisql_dnToAbMag" title="Converts a raw flux in DN to an AB magnitude.">scisql_dnToAbMag</a></li>
			<li><a href="#photometry-scisql_dnToAbMagSigma" title="Converts a raw flux error to an AB magnitude error.">scisql_dnToAbMagSigma</a></li>
			<li><a href="#photometry-scisql_dnToFlux" title="Converts a raw flux in DN to a calibrated (AB) flux.">scisql_dnToFlux</a></li>
			<li><a href="#photometry-scisql_dnToFluxSigma" title="Converts a raw flux error to a calibrated (AB) flux error.">scisql_dnToFluxSigma</a></li>
			<li><a href="#photometry-scisql_fluxToAbMag" title="Converts a calibrated (AB) flux to an AB magnitude.">scisql_fluxToAbMag</a></li>
			<li><a href="#photometry-scisql_fluxToAbMagSigma" title="Converts a calibrated (AB) flux error to an AB magnitude error.">scisql_fluxToAbMagSigma</a></li>
			<li><a href="#photometry-scisql_fluxToDn" title="Converts a calibrated (AB) flux to a raw DN value.">scisql_fluxToDn</a></li>
			<li><a href="#photometry-scisql_fluxToDnSigma" title="Converts a calibrated (AB) flux error to raw flux error in DN.">scisql_fluxToDnSigma</a></li>
			<li><a href="#photometry-scisql_nanojanskyToAbMag" title="Converts a calibrated (AB) flux to an AB magnitude.">scisql_nanojanskyToAbMag</a></li>
			<li><a href="#photometry-scisql_nanojanskyToAbMagSigma" title="Converts a calibrated (AB) flux error to an AB magnitude error.">scisql_nanojanskyToAbMagSigma</a></li>
		</ul>

	</li>
	<li>
		
	<h3><a href="#statistics">Statistics</a></h3>

		
		<ul class="section_nav">
			<li><a href="#statistics-scisql_median" title="Returns the median of a GROUP of values.">scisql_median</a></li>
			<li><a href="#statistics-scisql_percentile" title="Returns the desired percentile of a GROUP of values.">scisql_percentile</a></li>
		</ul>

	</li>
	<li>
		
	<h3><a href="#misc">Miscellaneous</a></h3>

		
		<h4>UDFs</h4>
		<ul class="section_nav">
			<li><a href="#misc-scisql_extractInt64" title="Extracts a 64-bit integer stored in host byte order from a binary string.">scisql_extractInt64</a></li>
			<li><a href="#misc-scisql_getVersion" title="Returns the version of the sciSQL library in use.">scisql_getVersion</a></li>
			<li><a href="#misc-scisql_raiseError" title="Fails with an optional error message.">scisql_raiseError</a></li>
		</ul>
		<h4>Stored Procedures</h4>
		<ul class="section_nav">
			<li><a href="#misc-scisql_grantPermissions" title="Gives a user connecting from the specified host permission to call sciSQL stored procedures and to create/use temporary tables in the scisql database.">scisql_grantPermissions</a></li>
		</ul>

	</li>
</ul>
</div> <!-- end of #nav -->


<div id="content">
        <!-- section anchors -->
        <a name="overview"></a>
        <a name="install"></a>
        <a name="s2"></a>
        <a name="photometry"></a>
        <a name="statistics"></a>
        <a name="misc"></a>

<div id="section-overview" class="section">
	
        <div class="section-docs">
        <p>
        sciSQL provides science-specific tools and extensions for SQL. Currently, the project contains user
        defined functions (UDFs) and stored procedures for MySQL or MariaDB in the areas of spherical
        geometry, statistics, and photometry. The project was motivated by the needs of the <a href="http://www.lsst.org/">Rubin Observatory Legacy Survey of Space and Time</a> (LSST) and has been
        sponsored by LSST and <a href="http://slac.stanford.edu/">SLAC</a> /
        <a href="http://www.energy.gov/">DOE</a>. sciSQL is distributed under the terms of the
        <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a>.
        </p>
        <ul>
                <li><a href="https://github.com/smonkewitz/scisql">Source code</a></li>
                <li><a href="https://github.com/smonkewitz/scisql/issues/new">Report a bug</a></li>
        </ul>
        <p>
        sciSQL is also distributed with a pair of Javascript libraries. These are:
        </p>
        <ul>
                <li>
                        <a href="http://jquery.com/">jQuery</a>, copyright John Resig and
                        dual-licensed under the <a href="http://jquery.org/license/">MIT
                        and GPL version 2 licenses</a>
                </li>
                <li>
                        <a href="http://code.google.com/p/google-code-prettify/">Google prettify</a>,
                        distributed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">
                        Apache License version 2.0</a>
                </li>
        </ul>
        </div>


</div> <!-- end of #section-overview -->

<div id="section-install" class="section">
	
        <div class="section-docs">
        <p>
        Read on for instructions on how to configure, build, test, install and uninstall the
        sciSQL software.
        </p>
        <h3>Prerequisites</h3>
        <dl>
                <dt><a href="http://www.python.org/download/">Python 2.5.x or later</a></dt>
                <dt><a href="http://python-future.org/index.html">Python future 0.16 or later</a></dt>
                <dt><a href="https://dev.mysql.com/downloads/mysql/">MySQL server 8.x</a> -or-
                  <a href="https://mariadb.com/downloads/">MariaDB server 10.x</a></dt>
                <dt><a href="https://github.com/PyMySQL/mysqlclient">mysqlclient 2.1.x or later</a></dt>
                <dd>
                        This is a Python DB API 2.0 implementation for MySQL/MariaDB, and is
                        required when running the unit tests and uninstalling sciSQL.
                </dd>
                <dt><a href="http://www.makotemplates.org/download.html">Mako 0.4 or later</a></dt>
                <dd>
                        This Python templating library is required when
                        rebuilding release documentation.
                </dd>
        </dl>
        <p>
        In order to install the UDFs, you will need write permission to the MySQL/MariaDB server
        plug-in directory, as well as a MySQL/MariaDB account with admin priviledges.
        </p>

        <h3 class="warning">Databases reserved for sciSQL use</h3>
        <p>
        The following database names are reserved for use by sciSQL:
        </p>
        <dl>
                <dt>scisql</dt>
                <dd>Contains sciSQL stored procedures.</dd>
                <dt>scisql_test</dt>
                <dd>Used by sciSQL unit tests.</dd>
                <dt>scisql_demo</dt>
                <dd>Contains sample data that can be used to exercise the sciSQL UDFs.</dd>
        </dl>
        <p>
        The scisql_demo database is dropped and re-created during installation. If you
        are using it for other things, you must migrate its contents to a different
        database prior to installing sciSQL. If you do not,
        <strong>YOU WILL LOSE DATA</strong>.
        </p>
        <p>
        Even though the scisql and scisql_test databases are never automatically
        dropped, their use is <strong>STRONGLY DISCOURAGED</strong>.
        </p>

        <h3>Build configuration</h3>
        <p>
        Run <tt>./configure</tt> from the top-level sciSQL directory. Passing <tt>--help</tt>
        will yield a list of configuration options. Here are the ones most likely to require
        tweaking if <tt>./configure</tt> doesn't work straight out of the box on your system:
        </p>
        <dl>
                <dt><tt>--mysql-dir</tt></dt>
                <dd>Set this to the top-level of the MySQL/MariaDB server install tree</dd>
                <dt><tt>--mysql-config</tt></dt>
                <dd>Point to <tt>mysql_config</tt> or <tt>mariadb_config</tt> configuration tool</dd>
                <dt><tt>--mysql-includes</tt></dt>
                <dd>Point to MySQL/MariaDB headers (<tt>mysql.h</tt> and dependents)</dd>
                <dt><tt>--scisql-prefix</tt></dt>
                <dd>
                This string will be used as a prefix for all sciSQL UDF and stored procedure
                names. You can specify an empty string, which will result in unprefixed names.
                The default is "scisql_".
                </dd>
        </dl>
        <p>
        If you wish to build/install only the sciSQL client utilities and documentation,
        run configure with the <tt>--client-only</tt> option. In this case, a MySQL/MariaDB server or
        client install is not required, the only executable generated is scisql_index
        (a utility which generates HTM indexes for tables of circles or polygons stored
        in tab-separated-value format).
        </p>

        <h3>Build</h3>
        <p>
        sciSQL is built and staged with the usual <tt>make</tt> and <tt>make install</tt>
        commands.
        </p>
        <p>
        You may wish to regenerate the HTML documentation if you've chosen a
        non-default value for <tt>--scisql-prefix</tt>, as the HTML distributed with release
        tar-balls is built under the assumption that <tt>--scisql-prefix="scisql_"</tt>.
        To do this, run <tt>make html_docs</tt>.
        </p>

        <h3>Deploying sciSQL in a MySQL/MariaDB instance</h3>
        <p> Assuming you've installed scisql in <tt>$PREFIX</tt>, update your <tt>PATH</tt> and
        <tt>PYTHONPATH</tt> as described below:
        <pre class="prettyprint lang-bash linenums">
export PATH="$PREFIX/bin:$PATH"
export PYTHONPATH="$PREFIX/python:$PATH"</pre>
        Check that you have access to a local server instance and run <tt>scisql-deploy.py</tt>. Passing
        <tt>--help</tt> will yield a list of configuration options. Here are the ones most likely to require
        tweaking:
        </p>
        <dl>
                <dt><tt>--mysql-user</tt></dt>
                <dd>Set this to the name of a MySQL/MariaDB admin user; defaults to <tt>root</tt></dd>
                <dt><tt>--mysql-bin</tt></dt>
                <dd>Point to the <tt>mysql</tt> or <tt>mariadb</tt> command-line client</dd>
                <dt><tt>--mysql-socket</tt></dt>
                <dd>Point to the MySQL/MariaDB server UNIX socket file</dd>
                <dt><tt>--verbose</tt></dt>
                <dd>Verbosity level; possible value are FATAL, ERROR, WARN, INFO, DEBUG</dd>
        </dl>
        <p>
        You will be prompted for the MySQL/MariaDB admin user password during configuration.
        If you run <tt>scisql-deploy.py</tt> in a script, you can
        use standard input, for example via a pipe, for providing this password.
        Connection details, including this password, are stored in a temporary directory in a file named
        <tt>my-client.cnf</tt> using the MySQL options file format. This temporary file is removed at the end
        of the process, unless you set the verbose level to DEBUG.
        </p>
        <p>
        The <tt>scisql-deploy.py</tt> command will CREATE the sciSQL UDFs, stored procedures, and
        databases (including the scisql_demo database). It will also automatically
        run the sciSQL integration tests, which check that sciSQL is correctly deployed.
        You can re-run the tests anytime by invoking <tt>scisql-deploy.py</tt> with the 
        <tt>--test</tt> option.
        </p>
        <p>
        Finally, note that after installation each UDF will be available under two
        names: one including a version number and one without. For example, assuming
        that <tt>--scisql-prefix="foo_"</tt> and that the sciSQL version number is
        <tt>1.2.3</tt>, a hypothetical UDF named <tt>bar</tt> would be available as:
        </p>
        <ul><li>foo_bar</li><li>foo_bar_1_2_3</li></ul>
        <p>
        Invoking <tt>scisql-deploy.py</tt> with the <tt>--undeploy</tt> option
        will drop the versioned sciSQL UDFs and stored
        procedures. It will also drop the unversioned UDFs/procedures, but only
        if the unversioned UDF/procedure was created by the version of
        sciSQL being uninstalled. As a consequence, it is possible to have
        multiple versions of sciSQL installed at the same time, and the behavior
        of two versions can be compared from within a single MySQL/MariaDB instance.
        An unversioned name will resolve to the most recently installed versioned
        name.
        </p>
        <p>
        An updeploy will also drop the scisql_demo database.
        </p>

        <h3>Rebuilding sciSQL</h3>
        <p>
        If you've already installed sciSQL, say using a UDF/procedure name
        prefix of "foo_", and then decide you'd like to change the prefix to "bar_",
        do the following from the top-level sciSQL directory:
        </p>
        <dl>
        <dt><tt>scisql-deploy.py ... --undeploy</tt></dt><dd>Uninstalls the UDFs and stored procedures named <tt>foo_*</tt>.</dd>
        <dt><tt>make distclean</tt></dt><dd>Removes all build products and configuration files.</dd>
        <dt><tt>configure --scisql-prefix=bar_ ...</tt></dt><dd>Reconfigures sciSQL (sets new name prefix).</dd>
        <dt><tt>make</tt></dt><dd>Rebuilds sciSQL.</dd>
        <dt><tt>make install</tt></dt><dd>Restages sciSQL.</dd>
        <dt><tt>scisql-deploy.py ...</tt></dt><dd>Redeploys sciSQL</dd>
        </dl>
        <p>
        No MySQL/MariaDB restart is required. Note that multiple installations of the same
        version of sciSQL with different UDF/procedure name prefixes can coexist on
        a single MySQL/MariaDB instance.
        </p>

        <h3>MySQL/MariaDB server restarts</h3>
        <p>
        Installing different versions of sciSQL, or multiple copies of the same
        version with different UDF/procedure name prefixes, does not require a
        server restart.
        </p>
        <p>
        Only sciSQL developers should need to perform restarts. They are
        required when changing the name of a UDF without changing the name of the
        shared library installed into the server plugin directory. In this case,
        an attempt to install the updated shared library will sometimes result in
        MySQL/MariaDB reporting that it cannot find symbol names that are actually
        present. This is presumably due to server and/or OS level caching
        effects, and restarting the server resolves the problem.
        </p>

        <h3>Reporting bugs and getting help</h3>
        <p>
        If you encounter test-case failures, or think you've identified a
        bug in the sciSQL code, or would just like to ask a question, please
        <a href="https://github.com/smonkewitz/scisql/issues">submit an issue</a>.
        </p>
        </div>


</div> <!-- end of #section-install -->

<div id="section-s2" class="section">
	
        <div class="section-docs">
        <p>
                The aim of the spherical geometry UDFs and stored procedures is to
                allow quick answers to the following sorts of questions:
        </p>
        <ol>
                <li>
                <em>Which points in a table lie inside a region on the sphere?</em> For example,
                an astronomer might wish to know which stars and galaxies lie inside the
                region of the sky observed by a single camera CCD.
                </li>
                <li>
                <em>Which spherical regions in a table contain a particular point?</em> For
                example, an astronomer might with to know which telescope images overlap
                the position of interesting object X.
                </li>
        </ol>

        <h3>HTM indexing</h3>
        <p>
                To accelerate these types of queries, sciSQL maps points/regions
                to the integer ID(s) of their containing/overlapping triangles in a
                Hierarchical Triangular Mesh (HTM). This is a decomposition of the
                unit sphere defined by A. Szalay, T. Budavari, G. Fekete at the
                Johns Hopkins University, and Jim Gray, Microsoft Research. See
                the following links for more information:
        </p>
        <ul>
                <li><a href="http://voservices.net/spherical/">http://voservices.net/spherical/</a></li>
                <li><a href="http://adsabs.harvard.edu/abs/2010PASP..122.1375B">http://adsabs.harvard.edu/abs/2010PASP..122.1375B</a></li>
        </ul>
        <p>
                To accelerate spatial queries, standard B-tree indexes are created
                on the point/region HTM IDs and spatial constraints are expressed
                in terms of those IDs. This allows the database optimizer to restrict
                the rows that must be considered by a spatial query.
        </p>
        <p>
                Read on to learn how to create and take advantage of HTM indexes on
                tables containing spatial data. The examples below can be run in the
                scisql_demo database, which contains all of the referenced tables
                and a tiny amount of sample data.
        </p>

        <h3>Supported region types</h3>
        <p>
                sciSQL supports 4 kinds of regions: longitude/latitude angle boxes,
                spherical circles (defined by a center and opening angle), spherical
                ellipses (the orthographic projection of a standard 2-d ellipse onto
                the sphere, where the 2-d ellipse is on a plane tangent to the unit
                sphere at the ellipse center), and spherical convex polygons (where
                polygon edges are great circles). Note also that spherical convex
                polygons have a binary representation, produced by
                scisql_s2CPolyToBin(), allowing them to be stored as values
                in a BINARY table column.
        </p>

        <h3>Points-in-region queries</h3>
        <p>
                sciSQL contains several UDFs for checking whether a point lies inside
                a region. These are: scisql_s2PtInBox(),
                scisql_s2PtInCircle(), scisql_s2PtInCPoly() and
                scisql_s2PtInEllipse(). They return 1 if the input point is
                inside the input region and 0 otherwise.
        </p>
        <p>
                Given these UDFs, a simple way to answer question 1 is illustrated by
                the following example:
        </p>
        <pre class="prettyprint lang-sql linenums">
SELECT objectId
    FROM Object
    WHERE scisql_s2PtInCircle(ra_PS, decl_PS, 0, 0, 0.01) = 1;</pre>
        <p>
                This query returns all the objects within 0.01 degrees of
                (RA, Dec) = (0, 0). It is inefficient for small search regions
                because the scisql_s2PtInCircle() UDF must be called for
                every row in the <tt>Object</tt> table.
        </p>
        <p>
                Lets assume that <tt>Object</tt> contains an indexed BIGINT column
                named <tt>htmId20</tt>. If it does not, the column and index can be
                added with ALTER TABLE. <tt>htmId20</tt> can be populated with the
                subdivision-level 20 HTM IDs of object positions as follows:
        </p>
        <pre class="prettyprint lang-sql linenums">
ALTER TABLE Object DISABLE KEYS;
UPDATE Object
    SET htmId20 = scisql_s2HtmId(ra_PS, decl_PS, 20);
ALTER TABLE Object ENABLE KEYS;</pre>
        <p>
                The HTM subdivision level must be between 0 and 24. At subdivision
                level N, there are 8*4<sup>N</sup> triangles in the mesh, so the
                higher subdivision levels correspond to finer tesselations of the
                unit sphere.
        </p>
        <p>
                Now that HTM IDs for object positions are available and indexed,
                the query above can be made more efficient:
        </p>
        <pre class="prettyprint lang-sql linenums">
CALL scisql.scisql_s2CircleRegion(0, 0, 0.01, 20);

SELECT o.objectId
    FROM Object AS o INNER JOIN scisql.Region AS r
         ON (o.htmId20 BETWEEN r.htmMin AND r.htmMax)
    WHERE scisql_s2PtInCircle(o.ra_PS, o.decl_PS, 0, 0, 0.01) = 1;</pre>
        <p>
                What's going on here? The first line in the example calls the
                scisql_s2CircleRegion() stored procedure. This procedure
                creates a temporary table called <tt>scisql.Region</tt> with two
                BIGINT NOT NULL columns named htmMin and htmMax. It then stores
                the HTM IDs overlapping the search region in <tt>scisql.Region</tt>
                (as ranges).
        </p>
        <p>
                Next, the original query is augmented with a join against
                <tt>scisql.Region</tt>. This limits the objects considered by
                scisql_s2PtInCircle() to those within the HTM triangles
                overlapping the search region; the index on htmId20 allows MySQL to
                retrieve these objects very quickly when the search region is small.
                Note that if the search region is large (meaning that a large fraction
                of the table being searched is inside the search region), then the
                original query may actually be faster.
        </p>
        <p>
                Here is another example, this time with a search region taken from
                a table called <tt>Science_Ccd_Exposure</tt>. This table includes a
                a column named <tt>poly</tt> that contains polygonal approximations
                to the regions of the sphere observed by CCD exposures.
        </p>
        <pre class="prettyprint lang-sql linenums">
SELECT poly FROM Science_Ccd_Exposure
    WHERE scienceCcdExposureId = 43856062009
    INTO @poly;

CALL scisql.scisql_s2CPolyRegion(@poly, 20);

SELECT o.objectId
    FROM Object AS o INNER JOIN scisql.Region AS r
         ON (o.htmId20 BETWEEN r.htmMin AND r.htmMax)
    WHERE scisql_s2PtInCPoly(o.ra_PS, o.decl_PS, @poly) = 1;</pre>
        <p>
                The first statement stores the polygonal boundary of a particular CCD
                exposure into the user variable <tt>@poly</tt>, the second computes
                overlapping HTM IDs, and the third performs the points-in-region
                query as before.
        </p>

        <h3>Regions-containing-point queries</h3>
        <p>
                An example for this type of query is:
        </p>
        <pre class="prettyprint lang-sql linenums">
SELECT scienceCcdExposureId FROM Science_Ccd_Exposure
    WHERE scisql_s2PtInCPoly(0, 0, poly) = 1;</pre>
        <p>
                This query returns all the CCD exposures containing the point
                (RA, Dec) = (0, 0). To accelerate it using HTM indexing, an
                auxiliary table is introduced:
        </p>
        <pre class="prettyprint lang-sql linenums">
CREATE TABLE Science_Ccd_Exposure_HtmId10 (
    scienceCcdExposureId BIGINT  NOT NULL,
    htmId10              INTEGER NOT NULL,
    PRIMARY KEY (htmId10, scienceCcdExposureId),
    KEY (scienceCcdExposureId)
);</pre>
        <p>
                <tt>Science_Ccd_Exposure_HtmId10</tt> will store the level 10 HTM ID
                of every triangle overlapping a CCD exposure. To populate it, start
                by dumping the primary key and polygon vertex colunms from
                <tt>Science_Ccd_Exposure</tt>:
        </p>
        <pre class="prettyprint lang-bash linenums">
rm -f /tmp/scisql_demo_ccds.tsv</pre>
        <pre class="prettyprint lang-sql linenums">
SELECT scienceCcdExposureId,
       llcRa, llcDecl,
       ulcRa, ulcDecl,
       urcRa, urcDecl,
       lrcRa, lrcDecl
    FROM Science_Ccd_Exposure
    INTO OUTFILE '/tmp/scisql_demo_ccds.tsv';</pre>
        <p>
                Then, run the sciSQL region indexing utility:
        </p>
        <pre class="prettyprint lang-bash linenums">
sudo chmod a+r /tmp/scisql_demo_ccds.tsv
scisql_index -l 10 /tmp/scisql_demo_htmid10.tsv /tmp/scisql_demo_ccds.tsv</pre>
        <p>
                and load the results:
        </p>
        <pre class="prettyprint lang-sql linenums">
TRUNCATE TABLE Science_Ccd_Exposure_HtmId10;
LOAD DATA LOCAL INFILE '/tmp/scisql_demo_htmid10.tsv' INTO TABLE Science_Ccd_Exposure_HtmId10;</pre>
        <p>
                The example regions-containing-point query can now be expressed
                more efficiently as:
        </p>
        <pre class="prettyprint lang-sql linenums">
SELECT sce.scienceCcdExposureId
    FROM Science_Ccd_Exposure AS sce, (
             SELECT scienceCcdExposureId
             FROM Science_Ccd_Exposure_HtmId10
             WHERE htmId10 = scisql_s2HtmId(0, 0, 10)
         ) AS h
    WHERE sce.scienceCcdExposureId = h.scienceCcdExposureId AND
          scisql_s2PtInCPoly(0, 0, sce.poly) = 1;</pre>
        </div>


	<h2>User Defined Functions</h2>
	
	<div id="udf-s2-scisql_angSep" class="udf">
		<h3><a name="s2-scisql_angSep"></a>scisql_angSep</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_angSep (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon1</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of first position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat1</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of first position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon2</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of second position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat2</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of second position.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_angSep (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">x1</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">X coordinate of first position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">y1</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">Y coordinate of first position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">z1</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">Z coordinate of first position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">x2</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">X coordinate of second position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">y2</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">Y coordinate of second position.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">z2</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits"></td>
				<td class="argdesc">Z coordinate of second position.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Returns the angular separation in degrees between two
        positions on the unit sphere.

        Positions may be specified either as spherical coordinate pairs
        (lon1, lat1) and (lon2, lat2), or as 3-vectors (x1, y1, z1) and
        (x2, y2, z2) with arbitrary norm. If spherical coordinates are used,
        all arguments are assumed to be in units of degrees.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned. MySQL
            does not currently support storage of IEEE special values. However,
            their presence is checked for to ensure reasonable behavior if a
            future MySQL release does end up supporting them.</li>
			<li class="">If spherical coordinates are passed in and either latitude
            angle is not in the [-90, 90] degree range, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_angSep(0, 0, 0, 90);
SELECT scisql_angSep(1, 0, 0, 0, 0, 1);
SELECT scisql_angSep(ra_PS, decl_PS, ra_SG, decl_SG) FROM Object LIMIT 10;
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2CPolyHtmRanges" class="udf internal">
		<h3><a name="s2-scisql_s2CPolyHtmRanges"></a>[internal] scisql_s2CPolyHtmRanges</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2CPolyHtmRanges (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">poly</td>
				<td class="argtype">BINARY,</td>
				<td class="argunits"></td>
				<td class="argdesc">Binary string representation of a polygon.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">level</td>
				<td class="argtype">INTEGER,</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM subdivision level, must be in range [0, 24].</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">maxranges</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">Maximum number of ranges to report.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS MEDIUMBLOB</td></tr>
		</table>
		<div class="description">
			Returns a binary-string representation of HTM ID ranges
        overlapping a spherical convex polygon. The polygon must
        be specified in binary-string form (as produced by
        scisql_s2CPolyToBin()).
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, this is an error
            and NULL is returned.</li>
			<li class="">If poly does not correspond to a valid binary serialization
            of a spherical convex polygon, this is an error and NULL
            is returned.</li>
			<li class="">If level does not lie in the range [0, 24], this is an
            error and NULL is returned.</li>
			<li class="">maxranges can be set to any value. In practice, its value
            is clamped such that the binary return string has size at
            most 16MB (fits in a MEDIUMBLOB). Negative values are
            interpreted to mean: "return as many ranges as possible
            subject to the 16MB output size limit".</li>
		</ul>
	</div>

	
	<div id="udf-s2-scisql_s2CPolyToBin" class="udf">
		<h3><a name="s2-scisql_s2CPolyToBin"></a>scisql_s2CPolyToBin</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2CPolyToBin (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v1Lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of first polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v1Lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of first polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v2Lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of second polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v2Lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of second polygon vertex.</td>
			</tr>
			<tr><td class="argkind">&nbsp;</td><td class="argname">...</td><td class="decl" colspan="3"></td></tr>
			<tr><td class="decl" colspan="5">) RETURNS BINARY</td></tr>
		</table>
		<div class="description">
			Returns a binary-string representation of a spherical convex
        polygon. The polygon must be specified as a sequence of at least
        3 and at most 20 vertices. An N vertex input will result in a
        binary string of length exactly 24*(N + 1).
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, NaN or +/-Inf, this is an error
            and NULL is returned.</li>
			<li class="">If any latitude angle lies outside of [-90, 90] degrees,
            this is an error and NULL is returned.</li>
			<li class="">Polygon vertices can be specified in either clockwise or
            counter-clockwise order. However, the vertices are assumed to be
            hemispherical, to define edges that do not intersect except at
            vertices, and to define edges that form a convex polygon.</li>
			<li class="">Input coordinate must be convertible to type DOUBLE PRECISION.
            If their actual type is BIGINT or DECIMAL, then the conversion
            can result in loss of precision and hence an inaccurate result.
            Loss of precision will not occur so long as the inputs are values of
            type DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT, or TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
CREATE TEMPORARY TABLE Poly (
    ra1  DOUBLE PRECISION NOT NULL,
    dec1 DOUBLE PRECISION NOT NULL,
    ra2  DOUBLE PRECISION NOT NULL,
    dec2 DOUBLE PRECISION NOT NULL,
    ra3  DOUBLE PRECISION NOT NULL,
    dec3 DOUBLE PRECISION NOT NULL,
    poly BINARY(96) DEFAULT NULL
);

INSERT INTO Poly VALUES (-10,  0,
                          10,  0,
                           0, 10,
                         NULL);

UPDATE Poly
    SET poly = scisql_s2CPolyToBin(
        ra1, dec1,
        ra2, dec2,
        ra3, dec3);
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2CircleHtmRanges" class="udf internal">
		<h3><a name="s2-scisql_s2CircleHtmRanges"></a>[internal] scisql_s2CircleHtmRanges</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2CircleHtmRanges (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of circle center.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of circle center.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">radius</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle radius.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">level</td>
				<td class="argtype">INTEGER,</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM subdivision level, must be in range [0, 24].</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">maxranges</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">Maximum number of ranges to report.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS MEDIUMBLOB</td></tr>
		</table>
		<div class="description">
			Returns a binary-string representation of HTM ID ranges
        overlapping a circle on the unit sphere. This string will be
        at most 16MB long, i.e. it will fit in a MEDIUMBLOB.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The centerLon, centerLat, and radius arguments must be
            convertible to type DOUBLE PRECISION. If they are of type
            BIGINT or DECIMAL, then the conversion can result in loss
            of precision and hence an inaccurate result. Loss of
            precision will not occur so long as the inputs are values
            of type DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT,
            or TINYINT.</li>
			<li class="">The level and maxranges arguments must be integers.</li>
			<li class="">If any parameter is NULL, NaN or +/-Inf, this is an error
            and NULL is returned.</li>
			<li class="">If centerLat is not in the [-90, 90] degree range,
            this is an error and NULL is returned.</li>
			<li class="">If radius is negative or greater than 180, this is
            an error and NULL is returned.</li>
			<li class="">If level does not lie in the range [0, 24], this is an
            error and NULL is returned.</li>
			<li class="">maxranges can be set to any value. In practice, its value
            is clamped such that the binary return string has size at
            most 16MB (fits in a MEDIUMBLOB). Negative values are
            interpreted to mean: "return as many ranges as possible
            subject to the 16MB output size limit".</li>
		</ul>
	</div>

	
	<div id="udf-s2-scisql_s2HtmId" class="udf">
		<h3><a name="s2-scisql_s2HtmId"></a>scisql_s2HtmId</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2HtmId (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of the point to index.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of the point to index.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">level</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM subdivision level, required to lie in the range [0, 24].</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS BIGINT</td></tr>
		</table>
		<div class="description">
			Returns the HTM ID of a point at the given
        subdivision level.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, NULL is returned.</li>
			<li class="">If lon or lat is NaN or +/-Inf, this is an error and NULL is
            returned (IEEE specials are not currently supported by MySQL).</li>
			<li class="">If lat lies outside of [-90, 90] degrees, this is an error
            and NULL is returned.</li>
			<li class="">If level is not in the range [0, 24], this is an error
            and NULL is returned.</li>
			<li class="">The lon and lat arguments must be convertible to type DOUBLE
            PRECISION. If their actual type is BIGINT or DECIMAL, then the
            conversion can result in loss of precision and hence an inaccurate
            result. Loss of precision will not occur so long as the inputs are
            values of type DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT or
            TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId, ra_PS, decl_PS, scisql_s2HtmId(ra_PS, decl_PS, 20)
    FROM Object LIMIT 10;
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2HtmLevel" class="udf">
		<h3><a name="s2-scisql_s2HtmLevel"></a>scisql_s2HtmLevel</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2HtmLevel (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">id</td>
				<td class="argtype">BIGINT</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM ID.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<div class="description">
			Returns the subdivision level of the given HTM ID.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If id is NULL or an invalid HTM ID, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_s2HtmLevel(32);
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2PtInBox" class="udf">
		<h3><a name="s2-scisql_s2PtInBox"></a>scisql_s2PtInBox</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2PtInBox (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lonMin</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Minimum longitude angle of points in box.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">latMin</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Minimum latitude angle points in box.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lonMax</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Maximum longitude angle of points in box.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">latMax</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Maximum latitude angle of points in box.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<div class="description">
			Returns 1 if the point (lon, lat) lies inside the given
        longitude/latitude angle box, and 0 otherwise. The UDF handles
        range reduction of longitudes so that one can easily test whether
        a point is inside a box spanning the 0/360 degree longitude angle
        discontinuity. However, performing this test with a UDF call will
        inhibit the optimizer from using indexes, so in some cases it may
        be preferrable to express the test in SQL.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, 0 is returned.</li>
			<li class="">If any parameter is NaN or +/-Inf, this is an error and NULL is
            returned (IEEE specials are not currently supported by MySQL).</li>
			<li class="">If lat, latMin or latMax lie outside of [-90, 90] degrees,
            this is an error and NULL is returned.</li>
			<li class="">If both lonMin and lonMax lie in the range [0, 360], then lonMax
            may be less than lonMin. For example, a box with lonMin = 350
            and lonMax = 10 includes points with longitudes in the ranges
            [350, 360) and [0, 10].</li>
			<li class="">If either lonMin or lonMax lies outside of [0, 360], then lonMin
            must be less than or equal to lonMax. Otherwise, NULL is returned.
            However, the two values can be arbitrarily large. If they are
            separated by 360 degrees or more, then the box spans [0, 360) in
            longitude. Otherwise, lonMin and lonMax are range reduced. So for
            example, a spherical box with lonMin = 350 and lonMax = 370
            includes longitudes in the ranges [350, 360) and [0, 10].</li>
			<li class="">Input values must be convertible to type DOUBLE PRECISION. If their
            actual types are BIGINT or DECIMAL, then the conversion can result
            in loss of precision and hence an inaccurate result. Loss of
            precision will not occur so long as the inputs are values of type
            DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT or TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId, ra_PS, decl_PS
    FROM Object
    WHERE scisql_s2PtInBox(ra_PS, decl_PS, -10, 10, 10, 20) = 1;
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2PtInCPoly" class="udf">
		<h3><a name="s2-scisql_s2PtInCPoly"></a>scisql_s2PtInCPoly</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2PtInCPoly (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">poly</td>
				<td class="argtype">VARBINARY</td>
				<td class="argunits"></td>
				<td class="argdesc">Binary-string representation of polygon.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2PtInCPoly (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v1Lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of first polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v1Lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of first polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v2Lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of second polygon vertex.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">v2Lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of second polygon vertex.</td>
			</tr>
			<tr><td class="argkind">&nbsp;</td><td class="argname">...</td><td class="decl" colspan="3"></td></tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<div class="description">
			Returns 1 if the point (lon, lat) lies inside the given
        spherical convex polygon and 0 otherwise. The polygon may
        be specified either as a VARBINARY byte string (as produced by
        scisql_s2CPolyToBin()), or as a sequence of at least 3
        and at most 20 vertex pairs.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, 0 is returned.</li>
			<li class="">If any coordinate is NaN or +/-Inf, this is an error and NULL is
            returned (IEEE specials are not currently supported by MySQL).</li>
			<li class="">If any latitude angle lies outside of [-90, 90] degrees,
            this is an error and NULL is returned.</li>
			<li class="">Polygon vertices can be specified in either clockwise or
            counter-clockwise order. However, vertices are assumed to be
            hemispherical, to define edges that do not intersect except at
            vertices, and to define edges that form a convex polygon.</li>
			<li class="">Coordinate values must be convertible to type DOUBLE PRECISION. If
            their actual types are BIGINT or DECIMAL, then the conversion can
            result in loss of precision and hence an inaccurate result. Loss of
            precision will not occur so long as the inputs are values of type
            DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT or TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scienceCcdExposureId
    FROM Science_Ccd_Exposure
    WHERE scisql_s2PtInCPoly(
        0.0, 0.0,
        llcRa, llcDecl,
        ulcRa, ulcDecl,
        urcRa, urcDecl,
        lrcRa, lrcDecl) = 1;
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2PtInCircle" class="udf">
		<h3><a name="s2-scisql_s2PtInCircle"></a>scisql_s2PtInCircle</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2PtInCircle (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle center longitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle center latitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">radius</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle radius.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<div class="description">
			Returns 1 if the point (lon, lat) lies inside the given
        spherical circle and 0 otherwise.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, 0 is returned.</li>
			<li class="">If any parameter is NaN or +/-Inf, this is an error and NULL is
            returned (IEEE specials are not currently supported by MySQL).</li>
			<li class="">If lat or centerLat lies outside of [-90, 90] degrees, this is an
            error and NULL is returned.</li>
			<li class="">If radius is negative or greater than 180, this is
            an error and NULL is returned.</li>
			<li class="">Input values must be convertible to type DOUBLE PRECISION. If their
            actual types are BIGINT or DECIMAL, then the conversion can result
            in loss of precision and hence an inaccurate result. Loss of
            precision will not occur so long as the inputs are values of type
            DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT or TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId, ra_PS, decl_PS
    FROM Object
    WHERE scisql_s2PtInCircle(ra_PS, decl_PS, 0.0, 0.0, 1.0) = 1;
</pre>
	</div>

	
	<div id="udf-s2-scisql_s2PtInEllipse" class="udf">
		<h3><a name="s2-scisql_s2PtInEllipse"></a>scisql_s2PtInEllipse</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_s2PtInEllipse (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Longitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">lat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Latitude angle of point to test.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Ellipse center longitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">centerLat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Ellipse center latitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">semiMajorAxisAngle</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">arcsec</td>
				<td class="argdesc">Semi-major axis length.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">semiMinorAxisAngle</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">arcsec</td>
				<td class="argdesc">Semi-minor axis length.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">positionAngle</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Ellipse position angle, east of north.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS INTEGER</td></tr>
		</table>
		<div class="description">
			Returns 1 if the point (lon, lat) lies inside the given
        spherical ellipse and 0 otherwise.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any parameter is NULL, 0 is returned.</li>
			<li class="">If any parameter is NaN or +/-Inf, this is an error and NULL is
            returned (IEEE specials are not currently supported by MySQL).</li>
			<li class="">If lat or centerLat lies outside of [-90, 90] degrees, this is an
            error and NULL is returned.</li>
			<li class="">If semiMinorAxisAngle is negative or greater than
            semiMajorAxisAngle, this is an error and NULL is returned.</li>
			<li class="">If semiMajorAxisAngle is greater than 36,000 arcsec (10 deg),
            this is an error and NULL is returned.</li>
			<li class="">All inputs must be convertible to type DOUBLE PRECISION. If their
            actual types are BIGINT or DECIMAL, then the conversion can result
            in loss of precision and hence an inaccurate result. Loss of
            precision will not occur so long as the inputs are values of type
            DOUBLE PRECISION, FLOAT, REAL, INTEGER, SMALLINT or TINYINT.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId, ra_PS, decl_PS
    FROM Object
    WHERE scisql_s2PtInEllipse(ra_PS, decl_PS, 0, 0, 10, 5, 90) = 1;
</pre>
	</div>

	<h2>Stored Procedures</h2>
	
	<div id="proc-s2-scisql_s2CPolyRegion" class="proc">
		<h3><a name="s2-scisql_s2CPolyRegion"></a>scisql.scisql_s2CPolyRegion</h3>
		<table class="signature">
			<tr>
				<td class="decl" colspan="5">PROCEDURE scisql.scisql_s2CPolyRegion (
				</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">poly</td>
				<td class="argtype">VARBINARY(255),</td>
				<td class="argunits"></td>
				<td class="argdesc">Binary-string representation of a polygon.</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">level</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM subdivision level, must be in range [0, 24].</td>
			</tr>
			<tr>
				<td class="decl" colspan="5">)</td>
			</tr>
		</table>
		<div class="description">
			Creates a temporary table `scisql.Region` containing HTM ID ranges
         for the HTM triangles overlapping the given spherical convex polygon.
         A maximum of 256 ranges will be returned. If the number of ID ranges 
         at the
         desired subdivision level exceeds this number, then the effective
         subdivision level is decreased. This strategy can reduce the number
         of ranges required to represent any input geometry to just 4, but
         makes the resulting range list a poorer (coarser, higher area)
         approximation to the input geometry.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The `scisql.Region` table is allowed to exist prior to calling
             scisql_s2CPolyRegion() - if it does, its contents are completely
             replaced.</li>
			<li class="">Before using this stored procedure, an adminstrator must GRANT
             the required permissions (e.g. using scisql_grantPermissions()).</li>
			<li class="">If any input is NULL, the procedure will fail.</li>
			<li class="">If poly is not a valid binary-string representation of a polygon
             (e.g. as produced by scisql_s2CPolyToBin()), the procedure will fail.</li>
			<li class="">If level does not lie in the range [0, 24], the procedure will
             fail.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
CALL scisql.scisql_s2CPolyRegion(scisql_s2CPolyToBin(0,0, 1,0, 0,1), 20);
SELECT * FROM scisql.Region;
</pre>
	</div>

	
	<div id="proc-s2-scisql_s2CircleRegion" class="proc">
		<h3><a name="s2-scisql_s2CircleRegion"></a>scisql.scisql_s2CircleRegion</h3>
		<table class="signature">
			<tr>
				<td class="decl" colspan="5">PROCEDURE scisql.scisql_s2CircleRegion (
				</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">centerLon</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle center longitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">centerLat</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle center latitude angle.</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">radius</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">deg</td>
				<td class="argdesc">Circle radius.</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">level</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">HTM subdivision level, must be in range [0, 24].</td>
			</tr>
			<tr>
				<td class="decl" colspan="5">)</td>
			</tr>
		</table>
		<div class="description">
			Creates a temporary table `scisql.Region` containing HTM ID ranges
         for the HTM triangles overlapping the given circle. A maximum of 
         256 ranges will be returned. If the number of ID ranges at the
         desired subdivision level exceeds this number, then the effective
         subdivision level is decreased. This strategy can reduce the number
         of ranges required to represent any input geometry to just 4, but
         makes the resulting range list a poorer (coarser, higher area)
         approximation to the input geometry.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The `scisql.Region` table is allowed to exist prior to calling
             scisql_s2CircleRegion() - if it does, its contents are completely
             replaced.</li>
			<li class="">Before using this stored procedure, an adminstrator must GRANT
             the required permissions (e.g. using scisql_grantPermissions()).</li>
			<li class="">If any input is NULL, NaN or +/-Inf, the procedure will fail.</li>
			<li class="">If centerLat does not lie in the [-90, 90] degree range, the
             procedure will fail.</li>
			<li class="">If level does not lie in the range [0, 24], the procedure will
             fail.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
CALL scisql.scisql_s2CircleRegion(0, 0, 0.5, 20);
SELECT * FROM scisql.Region;
</pre>
	</div>

</div> <!-- end of #section-s2 -->

<div id="section-photometry" class="section">
	
        <div class="section-docs"><p>
        These UDFs provide conversions between raw fluxes, calibrated (AB) fluxes
        and AB magnitudes.
        </p></div>


	<h2>User Defined Functions</h2>
	
	<div id="udf-photometry-scisql_abMagToDn" class="udf">
		<h3><a name="photometry-scisql_abMagToDn"></a>scisql_abMagToDn</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToDn (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude to convert to a raw flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude to a raw flux in DN.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToDn(20.5, 3.0e+12);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_abMagToDnSigma" class="udf">
		<h3><a name="photometry-scisql_abMagToDnSigma"></a>scisql_abMagToDnSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToDnSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">magSigma</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">mag</td>
				<td class="argdesc">Standard deviation of mag.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0Sigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of fluxMag0.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude error to a raw flux error in DN.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If either magSigma or fluxMag0Sigma is negative, NULL is
            returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToDnSigma(20.5, 0.01, 3.0e+12, 0.0);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_abMagToFlux" class="udf">
		<h3><a name="photometry-scisql_abMagToFlux"></a>scisql_abMagToFlux</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToFlux (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude to convert to a calibrated flux.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude to a calibrated flux.
        The return value is in erg/cm<sup>2</sup>/sec/Hz.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The mag argument must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If the mag argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToFlux(20.5);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_abMagToFluxSigma" class="udf">
		<h3><a name="photometry-scisql_abMagToFluxSigma"></a>scisql_abMagToFluxSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToFluxSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">magSigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">mag</td>
				<td class="argdesc">Standard deviation of mag.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude error to a calibrated flux error.
        The return value is in erg/cm<sup>2</sup>/sec/Hz.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If magSigma is negative, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToFluxSigma(20.5, 0.01);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_abMagToNanojansky" class="udf">
		<h3><a name="photometry-scisql_abMagToNanojansky"></a>scisql_abMagToNanojansky</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToNanojansky (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude to convert to a calibrated flux.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude to a calibrated flux.
        The return value is in nanojanskys.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The mag argument must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If the mag argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToNanojansky(20.5);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_abMagToNanojanskySigma" class="udf">
		<h3><a name="photometry-scisql_abMagToNanojanskySigma"></a>scisql_abMagToNanojanskySigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_abMagToNanojanskySigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">mag</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">mag</td>
				<td class="argdesc">AB magnitude.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">magSigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">mag</td>
				<td class="argdesc">Standard deviation of mag.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts an AB magnitude error to a calibrated flux error.
        The return value is in nanojanskys.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If magSigma is negative, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_abMagToNanojanskySigma(20.5, 0.01);
</pre>
	</div>

	
	<div id="udf-photometry-scisql_dnToAbMag" class="udf">
		<h3><a name="photometry-scisql_dnToAbMag"></a>scisql_dnToAbMag</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_dnToAbMag (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dn</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux to convert to an AB magnitude.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a raw flux in DN to an AB magnitude.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If either fluxMag0 or dn is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_dnToAbMag(src.psfFlux, ccd.fluxMag0)
    FROM Source AS src, Science_Ccd_Exposure ccd
    WHERE src.scienceCcdExposureId = ccd.scienceCcdExposureId
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_dnToAbMagSigma" class="udf">
		<h3><a name="photometry-scisql_dnToAbMagSigma"></a>scisql_dnToAbMagSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_dnToAbMagSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dn</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dnSigma</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of dn.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0Sigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of fluxMag0.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a raw flux error to an AB magnitude error.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If either dnSigma or fluxMag0Sigma is negative, NULL is returned.</li>
			<li class="">If either dn or fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_dnToAbMagSigma(
        src.psfFlux, src.psfFluxSigma, ccd.fluxMag0, ccd.fluxMag0Sigma)
    FROM Source AS src, Science_Ccd_Exposure ccd
    WHERE src.scienceCcdExposureId = ccd.scienceCcdExposureId
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_dnToFlux" class="udf">
		<h3><a name="photometry-scisql_dnToFlux"></a>scisql_dnToFlux</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_dnToFlux (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dn</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux to convert to a calibrated (AB) flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a raw flux in DN to a calibrated (AB) flux. The return
        value will be in units of erg/cm<sup>2</sup>/sec/Hz.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
-- An example using the LSST schema:
SELECT scisql_dnToFlux(src.psfFlux, ccd.fluxMag0)
    FROM Source AS src, Science_Ccd_Exposure ccd
    WHERE src.scienceCcdExposureId = ccd.scienceCcdExposureId
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_dnToFluxSigma" class="udf">
		<h3><a name="photometry-scisql_dnToFluxSigma"></a>scisql_dnToFluxSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_dnToFluxSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dn</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">dnSigma</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of dn.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0Sigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of fluxMag0.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a raw flux error to a calibrated (AB) flux error. The return
        value will be in units of erg/cm<sup>2</sup>/sec/Hz.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If either dnSigma or fluxMag0Sigma is negative, NULL is returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_dnToAbMagSigma(
        src.psfFlux, src.psfFluxSigma, ccd.fluxMag0, ccd.fluxMag0Sigma)
    FROM Source AS src, Science_Ccd_Exposure ccd
    WHERE src.scienceCcdExposureId = ccd.scienceCcdExposureId
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_fluxToAbMag" class="udf">
		<h3><a name="photometry-scisql_fluxToAbMag"></a>scisql_fluxToAbMag</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_fluxToAbMag (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Calibrated flux to convert to an AB magnitude.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux to an AB magnitude.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The flux argument must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If the flux argument is negative, zero, NULL, NaN, or +/-Inf,
            NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_fluxToAbMag(rFlux_PS)
    FROM Object
    WHERE rFlux_PS IS NOT NULL
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_fluxToAbMagSigma" class="udf">
		<h3><a name="photometry-scisql_fluxToAbMagSigma"></a>scisql_fluxToAbMagSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_fluxToAbMagSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Calibrated (AB) flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxSigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Standard deviation of flux.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux error to an AB magnitude error.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If the flux argument is negative or zero, NULL is returned.</li>
			<li class="">If the fluxSigma argument is negative, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_fluxToAbMagSigma(rFlux_PS, rFlux_PS_Sigma)
    FROM Object
    WHERE rFlux_PS IS NOT NULL and rFlux_PS_Sigma IS NOT NULL
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_fluxToDn" class="udf">
		<h3><a name="photometry-scisql_fluxToDn"></a>scisql_fluxToDn</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_fluxToDn (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Calibrated flux to convert to a raw DN value.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux to a raw DN value.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">Both arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If either argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_fluxToDn(rFlux_PS, 3.0e+12)
    FROM Object
    WHERE rFlux_PS IS NOT NULL
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_fluxToDnSigma" class="udf">
		<h3><a name="photometry-scisql_fluxToDnSigma"></a>scisql_fluxToDnSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_fluxToDnSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Calibrated (AB) flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxSigma</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">erg/cm<sup>2</sup>/sec/Hz</td>
				<td class="argdesc">Standard deviation of flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Raw flux of a zero-magnitude object.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxMag0Sigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">DN</td>
				<td class="argdesc">Standard deviation of fluxMag0.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux error to raw flux error in DN.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If fluxMag0 is negative or zero, NULL is returned.</li>
			<li class="">If either fluxSigma or fluxMag0Sigma is negative, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_fluxToDnSigma(
        rFlux_PS, rFlux_PS_Sigma, 3.0e+12, 0.0)
    FROM Object
    WHERE rFlux_PS IS NOT NULL
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_nanojanskyToAbMag" class="udf">
		<h3><a name="photometry-scisql_nanojanskyToAbMag"></a>scisql_nanojanskyToAbMag</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_nanojanskyToAbMag (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">nanojansky</td>
				<td class="argdesc">Calibrated flux to convert to an AB magnitude.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux to an AB magnitude.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">The flux argument must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If the flux argument is negative, zero, NULL, NaN, or +/-Inf,
            NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_nanojanskyToAbMag(rFlux_PS)
    FROM Object
    WHERE rFlux_PS IS NOT NULL
    LIMIT 10;
</pre>
	</div>

	
	<div id="udf-photometry-scisql_nanojanskyToAbMagSigma" class="udf">
		<h3><a name="photometry-scisql_nanojanskyToAbMagSigma"></a>scisql_nanojanskyToAbMagSigma</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_nanojanskyToAbMagSigma (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">flux</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits">nanojansky</td>
				<td class="argdesc">Calibrated (AB) flux.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">fluxSigma</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits">nanojansky</td>
				<td class="argdesc">Standard deviation of flux.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Converts a calibrated (AB) flux error to an AB magnitude error.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">All arguments must be convertible to type DOUBLE PRECISION.</li>
			<li class="">If any argument is NULL, NaN, or +/-Inf, NULL is returned.</li>
			<li class="">If the flux argument is negative or zero, NULL is returned.</li>
			<li class="">If the fluxSigma argument is negative, NULL is returned.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_nanojanskyToAbMagSigma(rFlux_PS, rFlux_PS_Sigma)
    FROM Object
    WHERE rFlux_PS IS NOT NULL and rFlux_PS_Sigma IS NOT NULL
    LIMIT 10;
</pre>
	</div>

</div> <!-- end of #section-photometry -->

<div id="section-statistics" class="section">
	
        <div class="section-docs"><p>
        These UDFs provide the ability to compute medians and percentiles. Averages and
        standard deviations can already be computed with the AVG and STDDEV SQL constructs.
        </p></div>


	<h2>User Defined Functions</h2>
	
	<div id="udf-statistics-scisql_median" class="udf">
		<h3><a name="statistics-scisql_median"></a>scisql_median</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">AGGREGATE FUNCTION scisql_median (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">value</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits"></td>
				<td class="argdesc">Value, column name or expression yielding input values.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Returns the median of a GROUP of values.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">NULL and NaN values are ignored. MySQL does not currently support
            storage of NaNs.  However, their presence is checked for to ensure
            reasonable behaviour if a future MySQL release does end up
            supporting them.</li>
			<li class="">If all input values for a GROUP are NULL/NaN, then NULL is returned.</li>
			<li class="">If there are no inputs, NULL is returned.</li>
			<li class="">If there are an even number of elements in the input GROUP,
            the return value is the mean of the two middle elements in a
            sorted copy of the GROUP.</li>
			<li class="">As previously mentioned, input values are coerced to be of type
            DOUBLE PRECISION. If the inputs are of type BIGINT or DECIMAL,
            then the coercion can result in loss of precision and hence an
            inaccurate result. Loss of precision will not occur so long as
            median() is called on values of type DOUBLE PRECISION, FLOAT,
            INTEGER, SMALLINT, or TINYINT.</li>
			<li class="">This UDF can handle a maximum of 2<sup>27</sup> (134,217,728)
            input values per GROUP.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId, scisql_median(psfFlux)
    FROM Source
    WHERE objectId IS NOT NULL
    GROUP BY objectId;
</pre>
	</div>

	
	<div id="udf-statistics-scisql_percentile" class="udf">
		<h3><a name="statistics-scisql_percentile"></a>scisql_percentile</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">AGGREGATE FUNCTION scisql_percentile (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">value</td>
				<td class="argtype">DOUBLE PRECISION,</td>
				<td class="argunits"></td>
				<td class="argdesc">Value, column name, or expression yielding input values.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">percent</td>
				<td class="argtype">DOUBLE PRECISION</td>
				<td class="argunits"></td>
				<td class="argdesc">Desired percentile, must lie in the range [0, 100].</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS DOUBLE PRECISION</td></tr>
		</table>
		<div class="description">
			Returns the desired percentile of a GROUP of values.

        Given a GROUP of N DOUBLE PRECISION values, percentile returns the
        value V such that at most floor(N * percent/100.0) of the values are
        less than V and at most N - floor(N * percent/100.0) are greater.

        The percent argument must not vary across the elements of a GROUP for
        which a percentile is being computed, or the return value is undefined.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">NULL and NaN values are ignored. MySQL does not currently support
            storage of NaNs.  However, their presence is checked for to ensure
            reasonable behaviour if a future MySQL release does end up
            supporting them.</li>
			<li class="">If all inputs are NULL/NaN, then NULL is returned.</li>
			<li class="">If there are no input values, NULL is returned.</li>
			<li class="">If the input GROUP contains exactly one value, that value is
            returned.</li>
			<li class="">If the percent argument is NULL or does not lie in the range
            [0, 100], NULL is returned.</li>
			<li class="">If (N - 1) * percent/100.0 = K is an integer, the value returned
            is the K-th smallest element in a sorted copy of the input GROUP A.
            Otherwise, the return value is A[k] + f*(A[k + 1] - A[k]), where
            k = floor(K) and f = K - k.</li>
			<li class="">As previously mentioned, input values are coerced to be of type
            DOUBLE PRECISION. If the inputs are of type BIGINT or DECIMAL,
            then the coercion can result in loss of precision and hence an
            inaccurate result. Loss of precision will not occur so long as
            median() is called on values of type DOUBLE PRECISION, FLOAT,
            INTEGER, SMALLINT, or TINYINT.</li>
			<li class="">This UDF can handle a maximum of 2<sup>27</sup> (134,217,728)
            input values per GROUP.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT objectId,
       scisql_percentile(psfFlux, 25) AS firstQuartile,
       scisql_percentile(psfFlux, 75) AS thirdQuartile
    FROM Source
    WHERE objectId IS NOT NULL
    GROUP BY objectId
    LIMIT 10;
</pre>
	</div>

</div> <!-- end of #section-statistics -->

<div id="section-misc" class="section">
	
        <div class="section-docs"><p>
        These UDFs and stored procedures are either administrative, internal, or
        informational - they are not directly useful for scientific computation / queries.
        </p></div>


	<h2>User Defined Functions</h2>
	
	<div id="udf-misc-scisql_extractInt64" class="udf internal">
		<h3><a name="misc-scisql_extractInt64"></a>[internal] scisql_extractInt64</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_extractInt64 (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">data</td>
				<td class="argtype">STRING,</td>
				<td class="argunits"></td>
				<td class="argdesc">Byte string to extract a 64-bit integer from.</td>
			</tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">idx</td>
				<td class="argtype">INTEGER</td>
				<td class="argunits"></td>
				<td class="argdesc">The index of the 64-bit integer to extract.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS BIGINT</td></tr>
		</table>
		<div class="description">
			Extracts a 64-bit integer stored in host byte order
        from a binary string.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">If any argument is NULL, NULL is returned.</li>
			<li class="">If idx is negative or out of range, NULL is returned.</li>
		</ul>
	</div>

	
	<div id="udf-misc-scisql_getVersion" class="udf">
		<h3><a name="misc-scisql_getVersion"></a>scisql_getVersion</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_getVersion (
				) RETURNS CHAR</td></tr>
		</table>
		<div class="description">
			Returns the version of the sciSQL library in use.
		</div>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_getVersion();
</pre>
	</div>

	
	<div id="udf-misc-scisql_raiseError" class="udf internal">
		<h3><a name="misc-scisql_raiseError"></a>[internal] scisql_raiseError</h3>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_raiseError (
				) RETURNS BIGINT</td></tr>
		</table>
		<table class="signature">
			<tr><td class="decl" colspan="5">FUNCTION scisql_raiseError (
			</td></tr>
			<tr>
				<td class="argkind">&nbsp;</td>
				<td class="argname">message</td>
				<td class="argtype">STRING</td>
				<td class="argunits"></td>
				<td class="argdesc">Error message.</td>
			</tr>
			<tr><td class="decl" colspan="5">) RETURNS BIGINT</td></tr>
		</table>
		<div class="description">
			Fails with an optional error message.
        <p>
            This UDF exists solely because MySQL 5.1 does not support
            SIGNAL in stored procedures. The error messages it produces
            are slightly more readable than the results of hacks like
            <tt>SELECT * FROM `Lorem ipsum dolor`</tt>.
        </p>
		</div>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
SELECT scisql_raiseError('Lorem ipsum dolor');
</pre>
	</div>

	<h2>Stored Procedures</h2>
	
	<div id="proc-misc-scisql_grantPermissions" class="proc">
		<h3><a name="misc-scisql_grantPermissions"></a>scisql.scisql_grantPermissions</h3>
		<table class="signature">
			<tr>
				<td class="decl" colspan="5">PROCEDURE scisql.scisql_grantPermissions (
				</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">user</td>
				<td class="argtype">VARCHAR(255),</td>
				<td class="argunits"></td>
				<td class="argdesc">User name - may not contain wildcards.</td>
			</tr>
			<tr>
				<td class="argkind">IN</td>
				<td class="argname">host</td>
				<td class="argtype">VARCHAR(255)</td>
				<td class="argunits"></td>
				<td class="argdesc">Host name - wildcards ('%') are allowed.</td>
			</tr>
			<tr>
				<td class="decl" colspan="5">)</td>
			</tr>
		</table>
		<div class="description">
			Gives a user connecting from the specified host permission to call
         sciSQL stored procedures and to create/use temporary tables in the
         scisql database.
		</div>
		<h5>Notes</h5>
		<ul class="notes">
			<li class="">You must have MySQL admin priviledges (including GRANT OPTION)
             to call this stored procedure.</li>
		</ul>
		<h5>Examples</h5>
		<pre class="prettyprint lang-sql linenums">
CALL scisql.scisql_grantPermissions('bob', 'localhost');
</pre>
	</div>

</div> <!-- end of #section-misc -->

</div> <!-- end of #content -->

<script type="text/javascript"><!--
	$(document).ready(prettyPrint);
	$(document).ready(function () {
		$('#content a[name]').each(function() {
			$(this).css('position', 'relative').css('top', '-90px').html('&nbsp;');
		});
		$('#nav a').each(function() {
			$(this).click(function() {
				var href = $(this).attr("href").substring(1);
				var loc = href.split('-');
				var section = loc[0];
				if (! $(this).hasClass('active')) {
					$('#nav a.active').removeClass('active');
					$(this).addClass('active');
				}
				if (loc.length > 1) {
					var seclink = $('#nav a[href="#' + section + '"]');
					$('#title').text(seclink.text());
					seclink.addClass('active');
				} else {
					$('#title').text($(this).text());
				}
				section = $('#section-' + section);
				if (section.filter(':visible').size() == 0) {
					$('#content div.section').filter(':visible').hide();
					section.fadeIn(300);
				}
			});
		});
		var _loc = null;
		var _hashchange = function() {
			var l = document.location.toString();
			if (l == _loc) {
				return;
			}
			_loc = l;
			var i = l.indexOf('#');
			var e = (i != -1) ? $('#nav a[href="' + l.substring(i) + '"]') : $('#nav a[href="#overview"]');
			e.click();
			// Opera doesn't scroll properly without this
			$(document).scrollTop($('#content a[name="' + l.substring(i + 1) + '"]').offset().top);
		};
		if ('onhashchange' in window) {
			window.onhashchange = _hashchange;
		} else {
			setInterval(_hashchange, 100);
		}
		$('#nav').height($(window).height() - 75);
		$(window).resize(function() {
			$('#nav').height($(window).height() - 75);
		});
		_hashchange();
	});
--></script>
</body>
</html>

